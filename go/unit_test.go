package golang_test

import (
	_ "embed"
	"encoding"
	"fmt"
	"testing"

	"github.com/google/uuid"
	"github.com/sergi/go-diff/diffmatchpatch"
	code "github.com/trwk76/gocode"
	golang "github.com/trwk76/gocode/go"
)

func TestUnit(t *testing.T) {
	for _, item := range testItems {
		defer func() {
			if r := recover(); r != nil {
				err, ok := r.(error)
				if !ok {
					err = fmt.Errorf("panic: %v", r)
				}

				t.Errorf("test '%s' failed: %s", item.name, err.Error())
			}
		}()

		unit := item.gen()
		res := code.WriteString("\t", func(w *code.Writer) { unit.Write(w) })

		dmp := diffmatchpatch.New()
		diffs := dmp.DiffMain(res, item.text, false)

		ok := true

		for _, itm := range diffs {
			if itm.Type != diffmatchpatch.DiffEqual {
				ok = false
			}
		}

		if !ok {
			t.Errorf("test '%s' failed: %s\n", item.name, dmp.DiffPrettyText(diffs))
		}
	}
}

type (
	testItem struct {
		name string
		gen  func() golang.Unit
		text string
	}
)

var testItems []testItem = []testItem{
	{
		name: "Simple",
		gen: func() golang.Unit {
			res := golang.Unit{
				Prefix:  golang.Comment(" THIS FILE IS AUTOMATICALLY GENERATED; DO NOT EDIT"),
				Package: golang.PkgName("my_test"),
			}

			uuid := golang.SymbolFor[uuid.UUID](&res)
			encMarsh := golang.SymbolFor[encoding.TextMarshaler](&res)
			encUnmarsh := golang.SymbolFor[encoding.TextUnmarshaler](&res)

			res.Decls = append(
				res.Decls,
				golang.TypeDecls{
					{
						ID: golang.ID("ID"),
						Spec: golang.StructType{
							Fields: []golang.StructField{
								{
									ID:   "Value",
									Type: uuid,
									Tags: golang.Tags{
										{
											Name:  "json",
											Value: "value",
										},
									},
								},
							},
						},
					},
				},
				golang.MethDecls{
					{
						Receiver: golang.Param{
							ID: golang.ID("i"),
							Type: golang.Symbol{
								ID: golang.ID("ID"),
							},
						},
						ID: golang.ID("MarshalText"),
						Return: golang.Params{
							{
								Type: golang.SliceType{
									Items: golang.Byte,
								},
							},
							{
								Type: golang.Error,
							},
						},
						Body: golang.BlockStmt{
							golang.ReturnStmt{
								Value: golang.CallExpr{
									Func: golang.MemberExpr{
										Value: golang.MemberExpr{
											Value: golang.Symbol{
												ID: golang.ID("i"),
											},
											ID: golang.ID("Value"),
										},
										ID: golang.ID("MarshalText"),
									},
								},
							},
						},
					},
					{
						Receiver: golang.Param{
							ID: golang.ID("i"),
							Type: golang.PtrType{
								Item: golang.Symbol{
									ID: golang.ID("ID"),
								},
							},
						},
						ID: golang.ID("UnmarshalText"),
						Params: golang.Params{
							{
								ID: golang.ID("raw"),
								Type: golang.SliceType{
									Items: golang.Byte,
								},
							},
						},
						Return: golang.Params{
							{
								Type: golang.Error,
							},
						},
						Body: golang.BlockStmt{
							golang.ReturnStmt{
								Value: golang.CallExpr{
									Func: golang.MemberExpr{
										Value: golang.MemberExpr{
											Value: golang.Symbol{
												ID: golang.ID("i"),
											},
											ID: golang.ID("Value"),
										},
										ID: golang.ID("UnmarshalText"),
									},
									Args: golang.Exprs{
										golang.Symbol{
											ID: golang.ID("raw"),
										},
									},
								},
							},
						},
					},
				},
				golang.VarDecls{
					{
						ID:   golang.Ignore,
						Type: encMarsh,
						Value: golang.StructExpr{
							Type: golang.Symbol{
								ID: golang.ID("ID"),
							},
						},
					},
					{
						ID:   golang.Ignore,
						Type: encUnmarsh,
						Value: golang.CastExpr{
							Type: golang.PtrType{
								Item: golang.Symbol{
									ID: golang.ID("ID"),
								},
							},
							Value: golang.Nil,
						},
					},
				},
			)

			return res
		},
		text: simpleText,
	},
}

//go:embed tests/simple_test.go
var simpleText string
